<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cloud Pixel Playground</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      color: #333;
    }

    .header {
      text-align: center;
      color: white;
      margin-bottom: 30px;
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    .header p {
      font-size: 1.1rem;
      opacity: 0.9;
    }

    .container {
      background: white;
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      max-width: 900px;
      width: 100%;
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 10px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #dc3545;
      animation: pulse 2s infinite;
    }

    .status-indicator.connected {
      background: #28a745;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      align-items: center;
    }

    .color-picker {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #colorPicker {
      width: 60px;
      height: 40px;
      border: 2px solid #ddd;
      border-radius: 8px;
      cursor: pointer;
    }

    .preset-colors {
      display: flex;
      gap: 8px;
    }

    .preset-color {
      width: 30px;
      height: 30px;
      border-radius: 6px;
      border: 2px solid #ddd;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .preset-color:hover {
      transform: scale(1.1);
      border-color: #667eea;
    }

    .preset-color.active {
      border: 3px solid #667eea;
      box-shadow: 0 0 0 2px white, 0 0 0 4px #667eea;
    }

    .button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      background: #667eea;
      color: white;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: 500;
    }

    .button:hover {
      background: #5568d3;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .button:active {
      transform: translateY(0);
    }

    .button.secondary {
      background: #6c757d;
    }

    .button.secondary:hover {
      background: #5a6268;
    }

    .canvas-container {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
      background: #f8f9fa;
      padding: 20px;
      border-radius: 10px;
    }

    #canvas {
      border: 3px solid #333;
      border-radius: 4px;
      cursor: crosshair;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .info {
      text-align: center;
      color: #666;
      font-size: 14px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 10px;
    }

    .info strong {
      color: #333;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #667eea;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .error {
      background: #f8d7da;
      color: #721c24;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      border: 1px solid #f5c6cb;
    }

    @media (max-width: 768px) {
      .header h1 {
        font-size: 1.8rem;
      }
      
      .container {
        padding: 20px;
      }

      #canvas {
        max-width: 100%;
        height: auto;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>‚òÅÔ∏è Cloud Pixel Playground</h1>
    <p>Collaborative 50√ó50 Pixel Canvas</p>
  </div>

  <div class="container">
    <div class="status-bar">
      <div class="status-item">
        <div class="status-indicator" id="statusIndicator"></div>
        <span id="statusText">Connecting...</span>
      </div>
      <div class="status-item">
        <span>üë• <strong><span id="userCount">0</span></strong> users online</span>
      </div>
    </div>

    <div id="errorContainer"></div>

    <div class="controls">
      <div class="color-picker">
        <label for="colorPicker"><strong>Color:</strong></label>
        <input type="color" id="colorPicker" value="#FF0000">
      </div>
      
      <div class="preset-colors">
        <div class="preset-color" style="background: #FF0000;" data-color="#FF0000" title="Red"></div>
        <div class="preset-color" style="background: #00FF00;" data-color="#00FF00" title="Green"></div>
        <div class="preset-color" style="background: #0000FF;" data-color="#0000FF" title="Blue"></div>
        <div class="preset-color" style="background: #FFFF00;" data-color="#FFFF00" title="Yellow"></div>
        <div class="preset-color" style="background: #FF00FF;" data-color="#FF00FF" title="Magenta"></div>
        <div class="preset-color" style="background: #00FFFF;" data-color="#00FFFF" title="Cyan"></div>
        <div class="preset-color" style="background: #000000;" data-color="#000000" title="Black"></div>
        <div class="preset-color" style="background: #FFFFFF;" data-color="#FFFFFF" title="White"></div>
      </div>
      
      <button class="button secondary" onclick="clearCanvas()">Clear Canvas</button>
    </div>

    <div class="canvas-container">
      <canvas id="canvas" width="500" height="500"></canvas>
    </div>

    <div class="info">
      <p>Click on pixels to draw! Your changes are instantly shared with all users.</p>
      <p><strong>Canvas:</strong> 50√ó50 pixels | <strong>Deployed:</strong> Kubernetes Microservices</p>
    </div>
  </div>

  <script src="/config.js"></script>
  <script>
    // Configuration
    const CONFIG = window.APP_CONFIG || {
      WS_URL: 'ws://localhost:3002',
      API_URL: 'http://localhost:3001'
    };

    const CANVAS_SIZE = 50;
    const PIXEL_SIZE = 10; // Canvas is 500x500, so each pixel is 10x10

    // Canvas setup
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const colorPicker = document.getElementById('colorPicker');
    const statusIndicator = document.getElementById('statusIndicator');
    const statusText = document.getElementById('statusText');
    const userCount = document.getElementById('userCount');
    const errorContainer = document.getElementById('errorContainer');

    let ws = null;
    let canvasData = {};
    let isDrawing = false;

    // Initialize
    async function init() {
      try {
        await loadCanvas();
        connectWebSocket();
        setupEventListeners();
      } catch (error) {
        showError('Failed to initialize application: ' + error.message);
      }
    }

    // Load canvas from API
    async function loadCanvas() {
      try {
        statusText.textContent = 'Loading canvas...';
        const response = await fetch(`${CONFIG.API_URL}/api/canvas`);
        
        if (!response.ok) {
          throw new Error('Failed to load canvas');
        }

        const data = await response.json();
        canvasData = data.pixels;
        drawCanvas();
        statusText.textContent = 'Canvas loaded';
      } catch (error) {
        console.error('Error loading canvas:', error);
        showError('Failed to load canvas. Please refresh the page.');
        throw error;
      }
    }

    // Draw entire canvas
    function drawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      for (let y = 0; y < CANVAS_SIZE; y++) {
        for (let x = 0; x < CANVAS_SIZE; x++) {
          const key = `${x},${y}`;
          const color = canvasData[key] || '#FFFFFF';
          drawPixel(x, y, color);
        }
      }
    }

    // Draw single pixel
    function drawPixel(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
      
      // Draw grid lines
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 0.5;
      ctx.strokeRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
    }

    // Connect to WebSocket
    function connectWebSocket() {
      try {
        ws = new WebSocket(CONFIG.WS_URL);

        ws.onopen = () => {
          console.log('WebSocket connected');
          statusIndicator.classList.add('connected');
          statusText.textContent = 'Connected';
          clearError();
        };

        ws.onmessage = (event) => {
          try {
            const message = JSON.parse(event.data);
            handleWebSocketMessage(message);
          } catch (error) {
            console.error('Error parsing message:', error);
          }
        };

        ws.onclose = () => {
          console.log('WebSocket disconnected');
          statusIndicator.classList.remove('connected');
          statusText.textContent = 'Disconnected';
          
          // Attempt to reconnect after 3 seconds
          setTimeout(connectWebSocket, 3000);
        };

        ws.onerror = (error) => {
          console.error('WebSocket error:', error);
          showError('Connection error. Retrying...');
        };
      } catch (error) {
        console.error('Failed to connect WebSocket:', error);
        showError('Failed to connect. Please check if the server is running.');
      }
    }

    // Handle WebSocket messages
    function handleWebSocketMessage(message) {
      switch (message.type) {
        case 'connected':
          console.log('Connected to server:', message.message);
          break;

        case 'pixel_updated':
          const { x, y, color } = message;
          canvasData[`${x},${y}`] = color;
          drawPixel(x, y, color);
          break;

        case 'stats':
          userCount.textContent = message.activeUsers;
          break;

        case 'error':
          showError(message.message);
          break;
      }
    }

    // Setup event listeners
    function setupEventListeners() {
      // Canvas click
      canvas.addEventListener('mousedown', handleCanvasClick);
      canvas.addEventListener('mousemove', handleCanvasMove);
      canvas.addEventListener('mouseup', () => { isDrawing = false; });
      canvas.addEventListener('mouseleave', () => { isDrawing = false; });

      // Touch support
      canvas.addEventListener('touchstart', handleTouchStart);
      canvas.addEventListener('touchmove', handleTouchMove);
      canvas.addEventListener('touchend', () => { isDrawing = false; });

      // Preset colors
      document.querySelectorAll('.preset-color').forEach(element => {
        element.addEventListener('click', () => {
          const color = element.dataset.color;
          colorPicker.value = color;
          
          // Update active state
          document.querySelectorAll('.preset-color').forEach(el => el.classList.remove('active'));
          element.classList.add('active');
        });
      });
    }

    // Handle canvas click
    function handleCanvasClick(e) {
      isDrawing = true;
      updatePixel(e);
    }

    // Handle canvas move (for drawing)
    function handleCanvasMove(e) {
      if (isDrawing) {
        updatePixel(e);
      }
    }

    // Handle touch start
    function handleTouchStart(e) {
      e.preventDefault();
      isDrawing = true;
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent('mousedown', {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      updatePixel(mouseEvent);
    }

    // Handle touch move
    function handleTouchMove(e) {
      e.preventDefault();
      if (isDrawing) {
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousemove', {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        updatePixel(mouseEvent);
      }
    }

    // Update pixel
    function updatePixel(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      const canvasX = (e.clientX - rect.left) * scaleX;
      const canvasY = (e.clientY - rect.top) * scaleY;
      
      const x = Math.floor(canvasX / PIXEL_SIZE);
      const y = Math.floor(canvasY / PIXEL_SIZE);
      
      if (x >= 0 && x < CANVAS_SIZE && y >= 0 && y < CANVAS_SIZE) {
        const color = colorPicker.value.toUpperCase();
        sendPixelUpdate(x, y, color);
      }
    }

    // Send pixel update via WebSocket
    function sendPixelUpdate(x, y, color) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'pixel_update',
          x,
          y,
          color
        }));
        
        // Optimistic update
        canvasData[`${x},${y}`] = color;
        drawPixel(x, y, color);
      } else {
        showError('Not connected to server');
      }
    }

    // Clear canvas
    async function clearCanvas() {
      if (!confirm('Are you sure you want to clear the entire canvas?')) {
        return;
      }

      try {
        const response = await fetch(`${CONFIG.API_URL}/api/canvas/reset`, {
          method: 'POST'
        });

        if (response.ok) {
          await loadCanvas();
        } else {
          showError('Failed to clear canvas');
        }
      } catch (error) {
        console.error('Error clearing canvas:', error);
        showError('Failed to clear canvas');
      }
    }

    // Show error message
    function showError(message) {
      errorContainer.innerHTML = `<div class="error">${message}</div>`;
      setTimeout(clearError, 5000);
    }

    // Clear error message
    function clearError() {
      errorContainer.innerHTML = '';
    }

    // Start application
    init();
  </script>
</body>
</html>
